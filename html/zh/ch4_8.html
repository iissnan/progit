<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Gitolite - 服务器上的 Git - Pro Git 简体中文版</title><link rel="stylesheet" type="text/css" href="../../assets/vendor/bootstrap/dist/css/bootstrap.min.css"><link rel="stylesheet" type="text/css" href="../../assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" type="text/css" href="../../assets/vendor/nprogress/nprogress.css"><link rel="stylesheet" type="text/css" href="../../assets/css/main.css"><link rel="shortcut icon" type="images/x-icon" href="../../assets/img/favicon.ico"></head><body><a href="#main" class="sr-only">SKIP TO CONTENT</a><div id="pjax-container"><div id="header" class="navbar navbar-fixed-top navbar-inverse"><div class="container"><div class="navbar-header"><a id="brand" href="/progit/"><img src="../../assets/img/git-logo.png" alt="git" class="logo"></a><button type="button" data-toggle="collapse" data-target=".navigation" class="navbar-toggle"><span class="sr-only">Toggle Navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button></div><div class="navbar-collapse collapse navigation"><ul class="nav navbar-nav"><li class="dropdown"><a data-toggle="dropdown" href="#" class="dropdown-toggle"><span class="octicon octicon-list-unordered"></span> 目录<b class="caret"></b></a><ul role="menu" class="dropdown-menu menu-toc"><li class="menu-toc-chapter"><a href="ch1_0.html">1   起步 </a><ul class="menu-section-links"><li><a href="ch1_1.html">1.1   关于版本控制 </a></li><li><a href="ch1_2.html">1.2   Git 简史 </a></li><li><a href="ch1_3.html">1.3   Git 基础 </a></li><li><a href="ch1_4.html">1.4   安装 Git </a></li><li><a href="ch1_5.html">1.5   初次运行 Git 前的配置 </a></li><li><a href="ch1_6.html">1.6   获取帮助 </a></li><li><a href="ch1_7.html">1.7   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch2_0.html">2   Git 基础 </a><ul class="menu-section-links"><li><a href="ch2_1.html">2.1   取得项目的 Git 仓库 </a></li><li><a href="ch2_2.html">2.2   记录每次更新到仓库 </a></li><li><a href="ch2_3.html">2.3   查看提交历史 </a></li><li><a href="ch2_4.html">2.4   撤消操作 </a></li><li><a href="ch2_5.html">2.5   远程仓库的使用 </a></li><li><a href="ch2_6.html">2.6   打标签 </a></li><li><a href="ch2_7.html">2.7   技巧和窍门 </a></li><li><a href="ch2_8.html">2.8   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch3_0.html">3   Git 分支 </a><ul class="menu-section-links"><li><a href="ch3_1.html">3.1   何谓分支 </a></li><li><a href="ch3_2.html">3.2   分支的新建与合并 </a></li><li><a href="ch3_3.html">3.3   分支的管理 </a></li><li><a href="ch3_4.html">3.4   利用分支进行开发的工作流程 </a></li><li><a href="ch3_5.html">3.5   远程分支 </a></li><li><a href="ch3_6.html">3.6   分支的衍合 </a></li><li><a href="ch3_7.html">3.7   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch4_0.html">4   服务器上的 Git </a><ul class="menu-section-links"><li><a href="ch4_1.html">4.1   协议 </a></li><li><a href="ch4_2.html">4.2   在服务器上部署 Git </a></li><li><a href="ch4_3.html">4.3   生成 SSH 公钥 </a></li><li><a href="ch4_4.html">4.4   架设服务器 </a></li><li><a href="ch4_5.html">4.5   公共访问 </a></li><li><a href="ch4_6.html">4.6   GitWeb </a></li><li><a href="ch4_7.html">4.7   Gitosis </a></li><li><a href="ch4_8.html">4.8   Gitolite </a></li><li><a href="ch4_9.html">4.9   Git 守护进程 </a></li><li><a href="ch4_10.html">4.10   Git 托管服务 </a></li><li><a href="ch4_11.html">4.11   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch5_0.html">5   分布式 Git </a><ul class="menu-section-links"><li><a href="ch5_1.html">5.1   分布式工作流程 </a></li><li><a href="ch5_2.html">5.2   为项目作贡献 </a></li><li><a href="ch5_3.html">5.3   项目的管理 </a></li><li><a href="ch5_4.html">5.4   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch6_0.html">6   Git 工具 </a><ul class="menu-section-links"><li><a href="ch6_1.html">6.1   修订版本（Revision）选择 </a></li><li><a href="ch6_2.html">6.2   交互式暂存 </a></li><li><a href="ch6_3.html">6.3   储藏（Stashing） </a></li><li><a href="ch6_4.html">6.4   重写历史 </a></li><li><a href="ch6_5.html">6.5   使用 Git 调试 </a></li><li><a href="ch6_6.html">6.6   子模块 </a></li><li><a href="ch6_7.html">6.7   子树合并 </a></li><li><a href="ch6_8.html">6.8   总结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch7_0.html">7   自定义 Git </a><ul class="menu-section-links"><li><a href="ch7_1.html">7.1   配置 Git </a></li><li><a href="ch7_2.html">7.2   Git属性 </a></li><li><a href="ch7_3.html">7.3   Git挂钩 </a></li><li><a href="ch7_4.html">7.4   Git 强制策略实例 #</a></li><li><a href="ch7_5.html">7.5   总结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch8_0.html">8   Git 与其他系统 </a><ul class="menu-section-links"><li><a href="ch8_1.html">8.1   Git 与 Subversion </a></li><li><a href="ch8_2.html">8.2   迁移到 Git </a></li><li><a href="ch8_3.html">8.3   总结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch9_0.html">9   Git 内部原理 </a><ul class="menu-section-links"><li><a href="ch9_1.html">9.1   底层命令 (Plumbing) 和高层命令 (Porcelain) </a></li><li><a href="ch9_2.html">9.2   Git 对象 </a></li><li><a href="ch9_3.html">9.3   Git References </a></li><li><a href="ch9_4.html">9.4   Packfiles </a></li><li><a href="ch9_5.html">9.5   The Refspec </a></li><li><a href="ch9_6.html">9.6   传输协议 </a></li><li><a href="ch9_7.html">9.7   维护及数据恢复 </a></li><li><a href="ch9_8.html">9.8   总结 </a></li></ul></li></ul></li></ul><ul class="nav navbar-nav navbar-right"><li class="dropdown"><a data-toggle="dropdown" href="#" class="dropdown-toggle"><span class="octicon octicon-globe"></span> 其他语言<b class="caret"></b></a><ul role="menu" class="dropdown-menu"><li><a href="../../index.en.html">English</a></li><li><a href="../../index.html">简体中文</a></li><li><a href="../../index.zh-tw.html">正體中文</a></li></ul></li><li><a href="../../about.html"><span class="octicon octicon-question"></span> 关于</a></li></ul></div></div></div><div id="main" class="container"><div class="row wrap"><div class="col-md-4"><div class="ph20"> <ul class="nav sub-nav"><li class="nav-header"><a href="ch4_0.html">服务器上的 Git</a></li><li><a href="ch4_1.html">协议</a></li><li><a href="ch4_2.html">在服务器上部署 Git</a></li><li><a href="ch4_3.html">生成 SSH 公钥</a></li><li><a href="ch4_4.html">架设服务器</a></li><li><a href="ch4_5.html">公共访问</a></li><li><a href="ch4_6.html">GitWeb</a></li><li><a href="ch4_7.html">Gitosis</a></li><li><a href="ch4_8.html">Gitolite</a></li><li><a href="ch4_9.html">Git 守护进程</a></li><li><a href="ch4_10.html">Git 托管服务</a></li><li><a href="ch4_11.html">小结</a></li></ul></div></div><div class="col-md-8"><div class="ph20"><h2>Gitolite</h2>

<p>本节作为Gitolite的一个快速指南，指导基本的安装和设置。不能完全替代随Gitolite自带的大量文档。而且可能会随时改变本节内容，因此你也许想看看最新的<a href="http://sitaramc.github.com/gitolite/progit.html">版本</a>。</p>

<p>Gitolite是在Git之上的一个授权层，依托<code>sshd</code>或者<code>httpd</code>来进行认证。（概括：认证是确定用户是谁，授权是决定该用户是否被允许做他想做的事情）。</p>

<p>Gitolite允许你定义访问许可而不只作用于仓库，而同样于仓库中的每个branch和tag name。你可以定义确切的人(或一组人)只能push特定的&quot;refs&quot;(或者branches或者tags)而不是其他人。</p>

<h3>安装</h3>

<p>安装Gitolite非常简单, 你甚至不用读自带的那一大堆文档。你需要一个unix服务器上的账户；许多linux变种和solaris 10都已经试过了。你不需要root访问，假设git，perl，和一个openssh兼容的ssh服务器已经装好了。在下面的例子里，我们会用<code>git</code>账户在<code>gitserver</code>进行。</p>

<p>Gitolite是不同于“服务”的软件 -- 其通过ssh访问, 而且每个在服务器上的userid都是一个潜在的“gitolite主机”。我们在这里描述最简单的安装方法，对于其他方法，请参考其文档。</p>

<p>开始，在你的服务器上创建一个名为<code>git</code>的用户，然后以这个用户登录。从你的工作站拷贝你的SSH公钥（也就是你用<code>ssh-keygen</code>默认生成的<code>~/.ssh/id_dsa.pub</code>文件），重命名为<code>&lt;yourname&gt;.pub</code>（我们这里使用<code>scott.pub</code>作为例子）。然后执行下面的命令：</p>

<pre><code>$ git clone git://github.com/sitaramc/gitolite
$ gitolite/install -ln
    # assumes $HOME/bin exists and is in your $PATH
$ gitolite setup -pk $HOME/scott.pub</code></pre>

<p>最后一个命令在服务器上创建了一个名为<code>gitolite-admin</code>的Git仓库。</p>

<p>最后，回到你的工作站，执行<code>git clone git@gitserver:gitolite-admin</code>。然后你就完成了！Gitolite现在已经安装在了服务器上，在你的工作站上，你也有一个名为<code>gitolite-admin</code>的新仓库。你可用通过更改这个仓库以及推送到服务器上来管理你的Gitolite配置。</p>

<h3>定制安装</h3>

<p>默认快速安装对大多数人都管用，还有一些定制安装方法如果你用的上的话。一些设置可以通过编辑rc文件来简单地改变，但是如果这个不够，有关于定制Gitolite的文档供参考。</p>

<h3>配置文件和访问规则</h3>

<p>安装结束后，你切换到<code>gitolite-admin</code>仓库（放在你的HOME目录）然后看看都有啥：</p>

<pre><code>$ cd ~/gitolite-admin/
$ ls
conf/  keydir/
$ find conf keydir -type f
conf/gitolite.conf
keydir/scott.pub
$ cat conf/gitolite.conf

repo gitolite-admin
    RW+                 = scott

repo testing
    RW+                 = @all</code></pre>

<p>注意 &quot;scott&quot; ( 之前用<code>gl-setup</code> 命令时候的 pubkey 名稱) 有读写权限而且在 <code>gitolite-admin</code> 仓库里有一个同名的公钥文件。</p>

<p>添加用户很简单。为了添加一个名为<code>alice</code>的用户，获取她的公钥，命名为<code>alice.pub</code>，然后放到在你工作站上的<code>gitolite-admin</code>克隆的<code>keydir</code>目录。添加，提交，然后推送更改。这样用户就被添加了。</p>

<p>gitolite配置文件的语法在<code>conf/example.conf</code>里，我们只会提到一些主要的。</p>

<p>你可以给用户或者仓库分组。分组名就像一些宏；定义的时候，无所谓他们是工程还是用户；区别在于你<em>使用</em>“宏”的时候</p>

<pre><code>@oss_repos      = linux perl rakudo git gitolite
@secret_repos   = fenestra pear

@admins         = scott
@interns        = ashok
@engineers      = sitaram dilbert wally alice
@staff          = @admins @engineers @interns</code></pre>

<p>你可以控制许可在”ref“级别。在下面的例子里，实习生可以push ”int“分支。工程师可以push任何有&quot;eng-&quot;开头的branch，还有refs/tags下面用&quot;rc&quot;开头的后面跟数字的。而且管理员可以随便更改(包括rewind)对任何参考名。</p>

<pre><code>repo @oss_repos
    RW  int$                = @interns
    RW  eng-                = @engineers
    RW  refs/tags/rc[0-9]   = @engineers
    RW+                     = @admins</code></pre>

<p>在<code>RW</code>or<code>RW+</code>之后的表达式是正则表达式(regex)对应着后面的push用的参考名字(ref)。所以我们叫它”参考正则“（refex）！当然，一个refex可以比这里表现的更强大，所以如果你对perl的正则表达式不熟的话就不要改过头。</p>

<p>同样，你可能猜到了，Gitolite字头<code>refs/heads/</code>是一个便捷句法如果参考正则没有用<code>refs/</code>开头。</p>

<p>一个这个配置文件语法的重要功能是，所有的仓库的规则不需要在同一个位置。你能报所有普通的东西放在一起，就像上面的对所有<code>oss_repos</code>的规则那样，然后建一个特殊的规则对后面的特殊案例，就像：</p>

<pre><code>repo gitolite
    RW+                     = sitaram</code></pre>

<p>那条规则刚刚加入规则集的 <code>gitolite</code> 仓库.</p>

<p>这次你可能会想要知道访问控制规则是如何应用的，我们简要介绍一下。</p>

<p>在gitolite里有两级访问控制。第一是在仓库级别；如果你已经读或者写访问过了任何在仓库里的参考，那么你已经读或者写访问仓库了。</p>

<p>第二级，应用只能写访问，通过在仓库里的branch或者tag。用户名如果尝试过访问 (<code>W</code>或<code>+</code>)，参考名被更新为已知。访问规则检查是否出现在配置文件里，为这个联合寻找匹配 (但是记得参考名是正则匹配的，不是字符串匹配的)。如果匹配被找到了，push就成功了。不匹配的访问会被拒绝。</p>

<h3>带&#39;拒绝&#39;的高级访问控制</h3>

<p>目前，我们只看过了许可是<code>R</code>,<code>RW</code>, 或者<code>RW+</code>这样子的。但是gitolite还允许另外一种许可：<code>-</code>，代表 ”拒绝“。这个给了你更多的能力，当然也有一点复杂，因为不匹配并不是唯一的拒绝访问的方法，因此规则的顺序变得无关了！</p>

<p>这么说好了，在前面的情况中，我们想要工程师可以rewind任意branch除了master和integ。 这里是如何做到的</p>

<pre><code>    RW  master integ    = @engineers
    -   master integ    = @engineers
    RW+                 = @engineers</code></pre>

<p>你再一次简单跟随规则从上至下知道你找到一个匹配你的访问模式的，或者拒绝。非rewind push到master或者integ 被第一条规则允许。一个rewind push到那些refs不匹配第一条规则，掉到第二条，因此被拒绝。任何push(rewind或非rewind)到参考或者其他master或者integ不会被前两条规则匹配，即被第三条规则允许。</p>

<h3>通过改变文件限制 push</h3>

<p>此外限制用户push改变到哪条branch的，你也可以限制哪个文件他们可以碰的到。比如, 可能Makefile (或者其他哪些程序) 真的不能被任何人做任何改动，因为好多东西都靠着它呢，或者如果某些改变刚好不对就会崩溃。你可以告诉 gitolite:</p>

<pre><code>repo foo
    RW                      =   @junior_devs @senior_devs

    -   VREF/NAME/Makefile  =   @junior_devs</code></pre>

<p>这是一个强力的公能写在 <code>conf/example.conf</code>里。</p>

<h3>个人分支</h3>

<p>Gitolite也支持一个叫”个人分支“的功能 (或者叫, ”个人分支命名空间“) 在合作环境里非常有用。</p>

<p>在 git世界里许多代码交换通过”pull“请求发生。然而在合作环境里，委任制的访问是‘绝不’，一个开发者工作站不能认证，你必须push到中心服务器并且叫其他人从那里pull。</p>

<p>这个通常会引起一些branch名称簇变成像 VCS里一样集中化，加上设置许可变成管理员的苦差事。</p>

<p>Gitolite让你定义一个”个人的“或者”乱七八糟的”命名空间字首给每个开发人员(比如，<code>refs/personal/&lt;devname&gt;/*</code>)；看在<code>doc/3-faq-tips-etc.mkd</code>里的&quot;personal branches&quot;一段获取细节。</p>

<h3>&quot;通配符&quot; 仓库</h3>

<p>Gitolite 允许你定义带通配符的仓库(其实还是perl正则式), 比如随便整个例子的话<code>assignments/s[0-9][0-9]/a[0-9][0-9]</code>。 这是一个非常有用的功能，需要通过设置<code>$GL_WILDREPOS = 1;</code> 在 rc文件中启用。允许你安排一个新许可模式(&quot;C&quot;)允许用户创建仓库基于通配符，自动分配拥有权对特定用户 - 创建者，允许他交出 R和 RW许可给其他合作用户等等。这个功能在<code>doc/4-wildcard-repositories.mkd</code>文档里</p>

<h3>其他功能</h3>

<p>我们用一些其他功能的例子结束这段讨论，这些以及其他功能都在 &quot;faqs, tips, etc&quot; 和其他文档里。</p>

<p><strong>记录</strong>: Gitolite 记录所有成功的访问。如果你太放松给了别人 rewind许可 (<code>RW+</code>) 和其他孩子弄没了 &quot;master&quot;， 记录文件会救你的命，如果其他简单快速的找到SHA都不管用。</p>

<p><strong>访问权报告</strong>: 另一个方便的功能是你尝试用ssh连接到服务器的时候发生了什么。Gitolite告诉你哪个 repos你访问过，那个访问可能是什么。这里是例子：</p>

<pre><code>    hello scott, this is git@git running gitolite3 v3.01-18-g9609868 on git 1.7.4.4

         R     anu-wsd
         R     entrans
         R  W  git-notes
         R  W  gitolite
         R  W  gitolite-admin
         R     indic_web_input
         R     shreelipi_converter</code></pre>

<p><strong>委托</strong>：真正的大安装，你可以把责任委托给一组仓库给不同的人然后让他们独立管理那些部分。这个减少了主管理者的负担，让他瓶颈更小。这个功能在他自己的文档目录里的 <code>doc/</code>下面。</p>

<p><strong>镜像</strong>: Gitolite可以帮助你维护多个镜像，如果主服务器挂掉的话在他们之间很容易切换。</p>

</div></div></div><div class="footer"><div class="pull-left"><span class="build-date">构建时间：2015-01-17 00:32:21</span>，<span class="build-source-version">基于书籍源码版本：<a href="https://github.com/progit/progit/tree/6895c8264604032f24ffdee44123b922aabadf5b" target="_blank">6895c82</a></span>，<span class="application-version">程序版本：0.0.7</span>。</div><div class="pull-right">制作者<a href="http://iissnan.com" target="_blank"> iissnan</a></div></div></div></div><script src="../../assets/vendor/jquery/dist/jquery.min.js"></script><script src="../../assets/vendor/jquery-pjax/jquery.pjax.js"></script><script src="../../assets/vendor/nprogress/nprogress.js"></script><script src="../../assets/vendor/bootstrap/dist/js/bootstrap.min.js"></script><script src="../../assets/js/main.js"></script></body></html>